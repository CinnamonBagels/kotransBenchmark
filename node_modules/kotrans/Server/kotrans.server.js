/**
 * server.connection.js
 * 
 * Server connection using node.js. To utilize this file, user must invoke the 
 * require() nodejs method.
 *
 * require('path/to/server.connection.js');
 * 
 * @author  Sam Ko
 */

'use strict';

var kotrans = kotrans || {};

kotrans.server = (function () {
    var fs = require('fs');
    var exec = require('child_process').exec;
    var http = require( 'http' );
    var path = require('path');
    var BinaryServer = require('binaryjs').BinaryServer;
    var async = require('async');
    //done signifies all files were transfered
    var Client2ServerFlag = {
        send : 'send',
        transferComplete: 'transferComplete'
    }

    //sent signifies that the file chunk was sent.
    var Server2ClientFlag = {
        sent: 'sent',
        updateClient: 'updateClient',
        commandComplete: 'commandComplete',
        error: 'error'
    }

	var socketServer;

    var uploadedBytes;

    var file;
    var percentComplete;

    var allowedDirectory;

    function createServer(options, callback) {
        var options = options || {};
        var server = options.server;
        var route = options.route;
        allowedDirectory = options.directory || __dirname;

        socketServer = new BinaryServer({ server: server, path : route });

        socketServer.on('connection', onSocketConnection);

        if(callback instanceof Function) {
            callback();
        }
        
    }

    //wait for new user connection
    var execQueue;
    var initialized = false;
    function onSocketConnection(client) {
        if(!initialized) {
            execQueue = [];
            uploadedBytes = 0;
            initialized = true;
        }
        console.log("Client connected with ID " + client.id);

        //work on the incoming stream from browsers
		client.on('stream', function (stream, meta) {
			if (meta.cmd === Client2ServerFlag.send) {
                file = fs.createWriteStream(path.join(allowedDirectory, meta.chunkName));

                file.on('error', function(err) {
                    console.log(err);
                    process.exit();
                });
				stream.pipe(file);    
			} else if(meta.cmd === Client2ServerFlag.transferComplete) {
                async.series(execQueue, function(err) {
                    if(err) console.log(err);
                    uploadedBytes = 0;
                    execQueue = [];
                    client.send({}, {
                        fileName: meta.fileName,
                        cmd: Server2ClientFlag.commandComplete
                    });
                });
            }

            // Sends data back to the client with a percentage complete with file name
			stream.on('data', function (data) {
                if(meta.cmd === Client2ServerFlag.send) {
                    uploadedBytes += data.length;
                    percentComplete = ((uploadedBytes / meta.fileSize) * 100).toPrecision(4);
                    //console.log(percentComplete);
                    client.send({}, {   percent: percentComplete,
                                        fileName: meta.fileName,
                                        cmd: Server2ClientFlag.updateClient
                    });
                }
			});

            // Send a message to the client that the fileChunk was successfully transferred.
			stream.on('end', function () {
                if(meta.cmd === Client2ServerFlag.send) {
                    execQueue.push(function(callback) {
                        var catCmd = concatenateFiles(meta);
                        var remCmd = removeFiles(meta);
                        executeCommand(catCmd, client, function() {
                            executeCommand(remCmd, client, function() {
                                callback();
                            });
                        });
                    });
                    client.send({}, { chunkName: meta.chunkName, cmd: Server2ClientFlag.sent });
                }
			});
        });
    }

    /*concatenates all file chunks into the original file
        Parameter is the metadata of the file(s) which include:
        meta.noFiles: the number of chunkFiles that were created.
        meta.name: the original file name 

        This function changes the directory and concatenates the files
        in a single command. */
    function concatenateFiles(meta) {
        var cmd;
        var fileName = meta.chunkName.split('_');
        fileName.pop();
        fileName.join('');
        cmd = 'cd ' + allowedDirectory + '; cat';

        cmd = cmd.concat(' "' + meta.chunkName + '"');

        cmd = cmd.concat(' >> "' + fileName + '"');

        return cmd;
    }

    /* Removes all file chunks that created the original file
        Parameter is the metadata of the file(s) which include:
        meta.noFiles: the number of chunkFiles that were created.
        meta.name: the original file name 

        This function changes the directory and removes the files in 
        a single command. */
    function removeFiles(meta) {
        var cmd;
        cmd = 'cd ' + allowedDirectory + ';rm';

        cmd = cmd.concat(' "' + meta.chunkName + '"');

        return cmd;
    }

    /* executes unix commands on the server.
        -- Parameters --
        cmd: the command to execute */
    function executeCommand(cmd, client, cbfun) {
        exec(cmd, function(error, stdout, stderr) {
            if(stdout) {
                console.log(stdout);
            }

            if(stderr) {
                console.log(stderr);
            }
            if(error) {
                //console.log(error);
                client.send({}, {cmd: Server2ClientFlag.error});
            }
            if(cbfun) {
                cbfun();
            }
        });
    }

    module.exports = {
        createServer: function(options, callback) {
            createServer(options, callback);
        }
    }
})();